/* tslint:disable */
/* eslint-disable */
/**
 * Ory Oathkeeper API
 * Documentation for all of Ory Oathkeeper\'s APIs. 
 *
 * The version of the OpenAPI document: v0.8.0-alpha.1
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * CreateRelationTupleBadRequestBody CreateRelationTupleBadRequestBody CreateRelationTupleBadRequestBody CreateRelationTupleBadRequestBody CreateRelationTupleBadRequestBody CreateRelationTupleBadRequestBody create relation tuple bad request body
 * @export
 * @interface CreateRelationTupleBadRequestBody
 */
export interface CreateRelationTupleBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateRelationTupleBadRequestBody
     */
    'status'?: string;
}
/**
 * CreateRelationTupleInternalServerErrorBody CreateRelationTupleInternalServerErrorBody CreateRelationTupleInternalServerErrorBody CreateRelationTupleInternalServerErrorBody CreateRelationTupleInternalServerErrorBody CreateRelationTupleInternalServerErrorBody create relation tuple internal server error body
 * @export
 * @interface CreateRelationTupleInternalServerErrorBody
 */
export interface CreateRelationTupleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateRelationTupleInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody DeleteRelationTuplesBadRequestBody delete relation tuples bad request body
 * @export
 * @interface DeleteRelationTuplesBadRequestBody
 */
export interface DeleteRelationTuplesBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRelationTuplesBadRequestBody
     */
    'status'?: string;
}
/**
 * DeleteRelationTuplesInternalServerErrorBody DeleteRelationTuplesInternalServerErrorBody DeleteRelationTuplesInternalServerErrorBody DeleteRelationTuplesInternalServerErrorBody DeleteRelationTuplesInternalServerErrorBody DeleteRelationTuplesInternalServerErrorBody delete relation tuples internal server error body
 * @export
 * @interface DeleteRelationTuplesInternalServerErrorBody
 */
export interface DeleteRelationTuplesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRelationTuplesInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * ExpandTree ExpandTree ExpandTree expand tree
 * @export
 * @interface ExpandTree
 */
export interface ExpandTree {
    /**
     * children
     * @type {Array<ExpandTree>}
     * @memberof ExpandTree
     */
    'children'?: Array<ExpandTree>;
    /**
     * subject id
     * @type {string}
     * @memberof ExpandTree
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof ExpandTree
     */
    'subject_set'?: SubjectSet;
    /**
     * type
     * @type {string}
     * @memberof ExpandTree
     */
    'type': ExpandTreeTypeEnum;
}

export const ExpandTreeTypeEnum = {
    UnionExclusionIntersectionLeaf: '[[[union exclusion intersection leaf]]]'
} as const;

export type ExpandTreeTypeEnum = typeof ExpandTreeTypeEnum[keyof typeof ExpandTreeTypeEnum];

/**
 * GenericError The standard error format
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * code
     * @type {number}
     * @memberof GenericError
     */
    'code'?: number;
    /**
     * details
     * @type {Array<{ [key: string]: object; }>}
     * @memberof GenericError
     */
    'details'?: Array<{ [key: string]: object; }>;
    /**
     * message
     * @type {string}
     * @memberof GenericError
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GenericError
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GenericError
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GenericError
     */
    'status'?: string;
}
/**
 * GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody GetCheckBadRequestBody get check bad request body
 * @export
 * @interface GetCheckBadRequestBody
 */
export interface GetCheckBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof GetCheckBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetCheckBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetCheckBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetCheckBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetCheckBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetCheckBadRequestBody
     */
    'status'?: string;
}
/**
 * GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody GetCheckInternalServerErrorBody get check internal server error body
 * @export
 * @interface GetCheckInternalServerErrorBody
 */
export interface GetCheckInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetCheckInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetCheckInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetCheckInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetCheckInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetCheckInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetCheckInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * The content of the allowed field is mirrored in the HTTP status code.
 * @export
 * @interface GetCheckResponse
 */
export interface GetCheckResponse {
    /**
     * whether the relation tuple is allowed
     * @type {boolean}
     * @memberof GetCheckResponse
     */
    'allowed': boolean;
}
/**
 * GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody GetExpandBadRequestBody get expand bad request body
 * @export
 * @interface GetExpandBadRequestBody
 */
export interface GetExpandBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof GetExpandBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetExpandBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetExpandBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetExpandBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetExpandBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetExpandBadRequestBody
     */
    'status'?: string;
}
/**
 * GetExpandInternalServerErrorBody GetExpandInternalServerErrorBody GetExpandInternalServerErrorBody GetExpandInternalServerErrorBody GetExpandInternalServerErrorBody GetExpandInternalServerErrorBody get expand internal server error body
 * @export
 * @interface GetExpandInternalServerErrorBody
 */
export interface GetExpandInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetExpandInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetExpandInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetExpandInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetExpandInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetExpandInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetExpandInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody GetExpandNotFoundBody get expand not found body
 * @export
 * @interface GetExpandNotFoundBody
 */
export interface GetExpandNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof GetExpandNotFoundBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetExpandNotFoundBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetExpandNotFoundBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetExpandNotFoundBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetExpandNotFoundBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetExpandNotFoundBody
     */
    'status'?: string;
}
/**
 * GetRelationTuplesInternalServerErrorBody GetRelationTuplesInternalServerErrorBody GetRelationTuplesInternalServerErrorBody GetRelationTuplesInternalServerErrorBody GetRelationTuplesInternalServerErrorBody GetRelationTuplesInternalServerErrorBody get relation tuples internal server error body
 * @export
 * @interface GetRelationTuplesInternalServerErrorBody
 */
export interface GetRelationTuplesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRelationTuplesInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * GetRelationTuplesNotFoundBody GetRelationTuplesNotFoundBody GetRelationTuplesNotFoundBody GetRelationTuplesNotFoundBody GetRelationTuplesNotFoundBody GetRelationTuplesNotFoundBody get relation tuples not found body
 * @export
 * @interface GetRelationTuplesNotFoundBody
 */
export interface GetRelationTuplesNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRelationTuplesNotFoundBody
     */
    'status'?: string;
}
/**
 * GetRelationTuplesResponse GetRelationTuplesResponse get relation tuples response
 * @export
 * @interface GetRelationTuplesResponse
 */
export interface GetRelationTuplesResponse {
    /**
     * The opaque token to provide in a subsequent request to get the next page. It is the empty string iff this is the last page.
     * @type {string}
     * @memberof GetRelationTuplesResponse
     */
    'next_page_token'?: string;
    /**
     * relation tuples
     * @type {Array<InternalRelationTuple>}
     * @memberof GetRelationTuplesResponse
     */
    'relation_tuples'?: Array<InternalRelationTuple>;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    'errors'?: { [key: string]: string; };
}
/**
 * HealthStatus health status
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Always \"ok\".
     * @type {string}
     * @memberof InlineResponse200
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The version of Ory Keto.
     * @type {string}
     * @memberof InlineResponse2001
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface InlineResponse503
 */
export interface InlineResponse503 {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof InlineResponse503
     */
    'errors': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InternalRelationTuple
 */
export interface InternalRelationTuple {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'namespace': string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'object': string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'relation': string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID are required.
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof InternalRelationTuple
     */
    'subject_set'?: SubjectSet;
}
/**
 * IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody is instance alive internal server error body
 * @export
 * @interface IsInstanceAliveInternalServerErrorBody
 */
export interface IsInstanceAliveInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta PatchDelta patch delta
 * @export
 * @interface PatchDelta
 */
export interface PatchDelta {
    /**
     * action
     * @type {string}
     * @memberof PatchDelta
     */
    'action'?: PatchDeltaActionEnum;
    /**
     * 
     * @type {InternalRelationTuple}
     * @memberof PatchDelta
     */
    'relation_tuple'?: InternalRelationTuple;
}

export const PatchDeltaActionEnum = {
    InsertDelete: '[[[[[[[[[[insert delete]]]]]]]]]]'
} as const;

export type PatchDeltaActionEnum = typeof PatchDeltaActionEnum[keyof typeof PatchDeltaActionEnum];

/**
 * PatchRelationTuplesBadRequestBody PatchRelationTuplesBadRequestBody PatchRelationTuplesBadRequestBody PatchRelationTuplesBadRequestBody PatchRelationTuplesBadRequestBody PatchRelationTuplesBadRequestBody patch relation tuples bad request body
 * @export
 * @interface PatchRelationTuplesBadRequestBody
 */
export interface PatchRelationTuplesBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof PatchRelationTuplesBadRequestBody
     */
    'status'?: string;
}
/**
 * PatchRelationTuplesInternalServerErrorBody PatchRelationTuplesInternalServerErrorBody PatchRelationTuplesInternalServerErrorBody PatchRelationTuplesInternalServerErrorBody PatchRelationTuplesInternalServerErrorBody PatchRelationTuplesInternalServerErrorBody patch relation tuples internal server error body
 * @export
 * @interface PatchRelationTuplesInternalServerErrorBody
 */
export interface PatchRelationTuplesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof PatchRelationTuplesInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * PatchRelationTuplesNotFoundBody PatchRelationTuplesNotFoundBody PatchRelationTuplesNotFoundBody PatchRelationTuplesNotFoundBody PatchRelationTuplesNotFoundBody PatchRelationTuplesNotFoundBody patch relation tuples not found body
 * @export
 * @interface PatchRelationTuplesNotFoundBody
 */
export interface PatchRelationTuplesNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof PatchRelationTuplesNotFoundBody
     */
    'status'?: string;
}
/**
 * PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody PostCheckBadRequestBody post check bad request body
 * @export
 * @interface PostCheckBadRequestBody
 */
export interface PostCheckBadRequestBody {
    /**
     * code
     * @type {number}
     * @memberof PostCheckBadRequestBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof PostCheckBadRequestBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof PostCheckBadRequestBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof PostCheckBadRequestBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof PostCheckBadRequestBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof PostCheckBadRequestBody
     */
    'status'?: string;
}
/**
 * PostCheckInternalServerErrorBody PostCheckInternalServerErrorBody PostCheckInternalServerErrorBody PostCheckInternalServerErrorBody PostCheckInternalServerErrorBody PostCheckInternalServerErrorBody post check internal server error body
 * @export
 * @interface PostCheckInternalServerErrorBody
 */
export interface PostCheckInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof PostCheckInternalServerErrorBody
     */
    'code'?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof PostCheckInternalServerErrorBody
     */
    'details'?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof PostCheckInternalServerErrorBody
     */
    'message'?: string;
    /**
     * reason
     * @type {string}
     * @memberof PostCheckInternalServerErrorBody
     */
    'reason'?: string;
    /**
     * request
     * @type {string}
     * @memberof PostCheckInternalServerErrorBody
     */
    'request'?: string;
    /**
     * status
     * @type {string}
     * @memberof PostCheckInternalServerErrorBody
     */
    'status'?: string;
}
/**
 * RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery RelationQuery relation query
 * @export
 * @interface RelationQuery
 */
export interface RelationQuery {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'namespace'?: string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'object'?: string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'relation'?: string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof RelationQuery
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof RelationQuery
     */
    'subject_set'?: SubjectSet;
}
/**
 * 
 * @export
 * @interface SubjectSet
 */
export interface SubjectSet {
    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'namespace': string;
    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'object': string;
    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'relation': string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    'version'?: string;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAlive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAlive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isReady(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.isAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.isReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - interface
 * @export
 * @interface MetadataApi
 */
export interface MetadataApiInterface {
    /**
     * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
     * @summary Return Running Software Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<InlineResponse2001>;

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    isAlive(options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server and Database Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    isReady(options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

}

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI implements MetadataApiInterface {
    /**
     * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
     * @summary Return Running Software Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isAlive(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server and Database Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isReady(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isReady(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReadApi - axios parameter creator
 * @export
 */
export const ReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand: async (namespace: string, object: string, relation: string, maxDepth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getExpand', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('getExpand', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('getExpand', 'relation', relation)
            const localVarPath = `/expand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples: async (pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck: async (maxDepth?: number, relationQuery?: RelationQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relationQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadApi - functional programming interface
 * @export
 */
export const ReadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReadApiAxiosParamCreator(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpand(namespace, object, relation, maxDepth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelationTuplesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCheck(maxDepth, relationQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReadApi - factory interface
 * @export
 */
export const ReadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReadApiFp(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any): AxiosPromise<ExpandTree> {
            return localVarFp.getExpand(namespace, object, relation, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<GetRelationTuplesResponse> {
            return localVarFp.getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.postCheck(maxDepth, relationQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadApi - interface
 * @export
 * @interface ReadApi
 */
export interface ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig): AxiosPromise<GetCheckResponse>;

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig): AxiosPromise<ExpandTree>;

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): AxiosPromise<GetRelationTuplesResponse>;

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {number} [maxDepth] 
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig): AxiosPromise<GetCheckResponse>;

}

/**
 * ReadApi - object-oriented interface
 * @export
 * @class ReadApi
 * @extends {BaseAPI}
 */
export class ReadApi extends BaseAPI implements ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getExpand(namespace, object, relation, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {number} [maxDepth] 
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).postCheck(maxDepth, relationQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple: async (relationQuery?: RelationQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relationQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuples: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples: async (patchDelta?: Array<PatchDelta>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchDelta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WriteApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationTuple(relationQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelationTuples(patchDelta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WriteApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple(relationQuery?: RelationQuery, options?: any): AxiosPromise<RelationQuery> {
            return localVarFp.createRelationTuple(relationQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: any): AxiosPromise<void> {
            return localVarFp.patchRelationTuples(patchDelta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WriteApi - interface
 * @export
 * @interface WriteApi
 */
export interface WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig): AxiosPromise<RelationQuery>;

    /**
     * Use this endpoint to delete relation tuples
     * @summary Delete Relation Tuples
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [patchDelta] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI implements WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).createRelationTuple(relationQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete relation tuples
     * @summary Delete Relation Tuples
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [patchDelta] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).patchRelationTuples(patchDelta, options).then((request) => request(this.axios, this.basePath));
    }
}


